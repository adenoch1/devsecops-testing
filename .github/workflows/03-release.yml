name: 03-release (ECR)

on:
  workflow_call:
    inputs:
      tfvars_path:
        description: "Path to terraform.tfvars used to compute name_prefix"
        required: false
        type: string
        default: "infra/envs/dev/terraform.tfvars"
      dockerfile_path:
        description: "Dockerfile path"
        required: false
        type: string
        default: "docker/Dockerfile"
      build_context:
        description: "Docker build context"
        required: false
        type: string
        default: "."
      image_tag:
        description: "Tag to use for the pushed image"
        required: true
        type: string
    outputs:
      deploy_tag:
        description: "The tag pushed to ECR"
        value: ${{ jobs.build_push.outputs.deploy_tag }}
      image_uri:
        description: "ECR image URI (registry/repo)"
        value: ${{ jobs.build_push.outputs.image_uri }}

  workflow_dispatch:
    inputs:
      image_tag:
        description: "Image tag to push (example: commit SHA)"
        required: true
        type: string
        default: "manual"

permissions:
  contents: read
  id-token: write

concurrency:
  group: 03-release-${{ github.ref }}
  cancel-in-progress: true

jobs:
  build_push:
    name: Build + Push (ECR)
    runs-on: ubuntu-latest

    outputs:
      deploy_tag: ${{ steps.meta.outputs.deploy_tag }}
      image_uri: ${{ steps.meta.outputs.image_uri }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN_ECR }}
          aws-region: ${{ secrets.AWS_REGION }}
          audience: sts.amazonaws.com

      - name: Verify AWS identity
        run: aws sts get-caller-identity

      - name: Login to Amazon ECR
        id: ecr_login
        uses: aws-actions/amazon-ecr-login@v2

      - name: Compute ECR repo + tag
        id: meta
        shell: bash
        run: |
          set -euo pipefail

          TFVARS="${{ inputs.tfvars_path }}"
          if [ ! -f "$TFVARS" ]; then
            echo "ERROR: tfvars not found at: $TFVARS"
            exit 1
          fi

          PROJECT=$(grep -E '^\s*project\s*=' "$TFVARS" | head -n1 | awk -F\" '{print $2}')
          ENVIRONMENT=$(grep -E '^\s*environment\s*=' "$TFVARS" | head -n1 | awk -F\" '{print $2}')

          if [ -z "$PROJECT" ] || [ -z "$ENVIRONMENT" ]; then
            echo "ERROR:: Could not read project/environment from $TFVARS"
            exit 1
          fi

          NAME_PREFIX="${PROJECT}-${ENVIRONMENT}"
          REPO_NAME="${NAME_PREFIX}-repo"

          REGISTRY="${{ steps.ecr_login.outputs.registry }}"
          IMAGE_URI="${REGISTRY}/${REPO_NAME}"

          TAG="${{ inputs.image_tag }}"
          if [ -z "$TAG" ]; then
            echo "ERROR:: image_tag input is empty."
            exit 1
          fi

          echo "REPO_NAME=$REPO_NAME" >> $GITHUB_ENV
          echo "IMAGE_URI=$IMAGE_URI" >> $GITHUB_ENV

          echo "image_uri=$IMAGE_URI" >> $GITHUB_OUTPUT
          echo "deploy_tag=$TAG" >> $GITHUB_OUTPUT

          echo "IMAGE_URI=$IMAGE_URI"
          echo "DEPLOY_TAG=$TAG"

      - name: Guardrail — verify ECR repository exists
        shell: bash
        run: |
          set -euo pipefail
          if aws ecr describe-repositories --repository-names "${REPO_NAME}" >/dev/null 2>&1; then
            echo "ECR repo exists: ${REPO_NAME}"
          else
            echo ":error:ECR repo ${REPO_NAME} does not exist"
            echo "This must be created by Terraform first."
            exit 1
          fi

      - name: Guardrail — immutable tags (skip bootstrap/latest if they already exist)
        id: tags
        shell: bash
        run: |
          set -euo pipefail

          DEPLOY_TAG="${{ steps.meta.outputs.deploy_tag }}"
          REPO="${REPO_NAME}"

          # 1) If deploy tag already exists, fail fast (immutable repos cannot overwrite)
          if aws ecr describe-images --repository-name "${REPO}" --image-ids imageTag="${DEPLOY_TAG}" >/dev/null 2>&1; then
            echo "error:ECR tag '${DEPLOY_TAG}' already exists in '${REPO}' and tags are immutable. Choose a new deploy tag."
            exit 1
          fi

          # 2) bootstrap tag: add only if not present
          BOOTSTRAP_LINE=""
          if aws ecr describe-images --repository-name "${REPO}" --image-ids imageTag="bootstrap" >/dev/null 2>&1; then
            echo "bootstrap tag already exists (immutable) — will NOT push bootstrap"
          else
            BOOTSTRAP_LINE="${IMAGE_URI}:bootstrap"
            echo "bootstrap tag not found — will push bootstrap"
          fi

          # 3) latest tag: add only if not present (immutable repos can't overwrite)
          LATEST_LINE=""
          if aws ecr describe-images --repository-name "${REPO}" --image-ids imageTag="latest" >/dev/null 2>&1; then
            echo "latest tag already exists (immutable) — will NOT push latest"
          else
            LATEST_LINE="${IMAGE_URI}:latest"
            echo "latest tag not found — will push latest"
          fi

          # Build tags list (always include deploy tag)
          {
            echo "tags<<EOF"
            echo "${IMAGE_URI}:${DEPLOY_TAG}"
            if [ -n "${BOOTSTRAP_LINE}" ]; then echo "${BOOTSTRAP_LINE}"; fi
            if [ -n "${LATEST_LINE}" ]; then echo "${LATEST_LINE}"; fi
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

          echo "Final tags to push:"
          echo "${IMAGE_URI}:${DEPLOY_TAG}"
          if [ -n "${BOOTSTRAP_LINE}" ]; then echo "${BOOTSTRAP_LINE}"; fi
          if [ -n "${LATEST_LINE}" ]; then echo "${LATEST_LINE}"; fi

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push image to ECR
        uses: docker/build-push-action@v6
        with:
          context: ${{ inputs.build_context }}
          file: ${{ inputs.dockerfile_path }}
          push: true
          pull: true
          no-cache: true
          tags: ${{ steps.tags.outputs.tags }}
