name: terraform-release

on:
  push:
    branches: ["main"]
    paths:
      - "infra/**"
      - "modules/**"
      - "app/**"
      - "docker/**"
      - ".github/workflows/terraform-release.yml"
      - ".github/workflows/03-release.yml"

  workflow_dispatch:
    inputs:
      action:
        description: "deploy or destroy"
        required: true
        default: "deploy"
        type: choice
        options: [deploy, destroy]
      fqdn:
        description: "Custom domain to test (example: app.example.com). Optional."
        required: false
        default: ""
      smoke_path:
        description: "Path to test (example: /health)"
        required: true
        default: "/health"
        type: string

permissions:
  id-token: write
  contents: read

concurrency:
  group: terraform-release-${{ github.ref }}
  cancel-in-progress: true

env:
  TF_IN_AUTOMATION: "true"
  TF_INPUT: "false"
  TF_CLI_ARGS: "-no-color"
  TF_VERSION: "1.6.6"
  WORKDIR: "infra/envs/dev"

jobs:
  ######################################################
  # Gate 1 (DEV): Infra Bootstrap (safe even before image)
  ######################################################
  infra_bootstrap:
    name: Bootstrap — Infra (dev)
    if: ${{ github.event_name == 'push' || inputs.action == 'deploy' }}
    runs-on: ubuntu-latest
    environment: dev

    defaults:
      run:
        working-directory: ${{ env.WORKDIR }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN_APPLY }}
          aws-region: ${{ secrets.AWS_REGION }}
          audience: sts.amazonaws.com

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Terraform init
        run: terraform init -input=false

      - name: Terraform plan (bootstrap)
        run: |
          terraform plan \
            -out=tfplan.bootstrap \
            -var="container_image_tag=bootstrap" \
            -var="desired_count=0"

      - name: Terraform apply (bootstrap)
        run: terraform apply -auto-approve tfplan.bootstrap

      - name: Helpful outputs (ALB DNS)
        shell: bash
        run: |
          set -euo pipefail
          echo "==== Terraform outputs ===="
          terraform output || true
          echo ""
          echo "If you need the ALB DNS name for your DNS CNAME:"
          if terraform output -raw alb_dns_name >/dev/null 2>&1; then
            echo "ALB DNS: $(terraform output -raw alb_dns_name)"
          elif terraform output -raw alb_dns >/dev/null 2>&1; then
            echo "ALB DNS: $(terraform output -raw alb_dns)"
          else
            echo "::warning::ALB DNS output not found. Add an output like: output \"alb_dns_name\" { value = aws_lb.<name>.dns_name }"
          fi

  #######################################################
  # Build & Push (ECR) — calls reusable workflow
  #######################################################
  build_push:
    name: Build & Push (ECR)
    needs: infra_bootstrap
    if: ${{ github.event_name == 'push' || inputs.action == 'deploy' }}
    uses: ./.github/workflows/03-release.yml
    secrets: inherit
    with:
      image_tag: ${{ github.sha }}
      tfvars_path: infra/envs/dev/terraform.tfvars
      dockerfile_path: docker/Dockerfile
      build_context: .

  ######################################################
  # Deploy — apply with the immutable SHA tag + desired_count=1
  ######################################################
  deploy:
    name: Deploy (dev)
    needs: build_push
    if: ${{ github.event_name == 'push' || inputs.action == 'deploy' }}
    runs-on: ubuntu-latest
    environment: dev

    defaults:
      run:
        working-directory: ${{ env.WORKDIR }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN_APPLY }}
          aws-region: ${{ secrets.AWS_REGION }}
          audience: sts.amazonaws.com

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Terraform init
        run: terraform init -input=false

      - name: Terraform plan (deploy)
        run: |
          terraform plan \
            -out=tfplan.deploy \
            -var="container_image_tag=${{ needs.build_push.outputs.deploy_tag }}" \
            -var="desired_count=1"

      - name: Terraform apply (deploy)
        run: terraform apply -auto-approve tfplan.deploy

      - name: Wait for ECS stable + Target Group healthy (FAILS if unhealthy)
        shell: bash
        run: |
          set -euo pipefail

          CLUSTER="$(terraform output -raw ecs_cluster_name 2>/dev/null || terraform output -raw cluster_name 2>/dev/null || true)"
          SERVICE="$(terraform output -raw ecs_service_name 2>/dev/null || terraform output -raw service_name 2>/dev/null || true)"
          TG_ARN="$(terraform output -raw target_group_arn 2>/dev/null || true)"

          if [ -z "${CLUSTER}" ] || [ -z "${SERVICE}" ]; then
            echo "::error::Missing ECS outputs (ecs_cluster_name / ecs_service_name). Add outputs in Terraform."
            exit 1
          fi

          echo "Waiting for ECS service to become stable: ${CLUSTER}/${SERVICE}"
          if ! aws ecs wait services-stable --cluster "${CLUSTER}" --services "${SERVICE}"; then
            echo "Error: ECS service did not become stable. Dumping diagnostics..."
            echo "---- ECS events (latest 20) ----"
            aws ecs describe-services --cluster "${CLUSTER}" --services "${SERVICE}" \
              --query "services[0].events[0:20].[message]" --output table || true

            echo "---- STOPPED tasks (latest 5) ----"
            STOPPED="$(aws ecs list-tasks --cluster "${CLUSTER}" --service-name "${SERVICE}" --desired-status STOPPED --max-results 5 --query "taskArns[]" --output text || true)"
            echo "${STOPPED}" || true

            if [ -n "${STOPPED}" ]; then
              for T in ${STOPPED}; do
                echo "---- Task stopped details: ${T} ----"
                aws ecs describe-tasks --cluster "${CLUSTER}" --tasks "${T}" \
                  --query "tasks[0].{last:lastStatus,stopCode:stopCode,stoppedReason:stoppedReason,exit:containers[0].exitCode,reason:containers[0].reason}" \
                  --output json || true
              done
            fi

            if [ -n "${TG_ARN}" ]; then
              echo "---- Target health (full reasons) ----"
              aws elbv2 describe-target-health --target-group-arn "${TG_ARN}" --output table || true
            fi
            exit 1
          fi

          if [ -z "${TG_ARN}" ]; then
            echo "::warning::target_group_arn output not found; skipping TG health validation"
            exit 0
          fi

          echo "Checking Target Group health for: ${TG_ARN}"
          HEALTHY=0
          for i in {1..30}; do
            STATES="$(aws elbv2 describe-target-health --target-group-arn "${TG_ARN}" --query "TargetHealthDescriptions[].TargetHealth.State" --output text || true)"
            echo "Attempt ${i} — target states: ${STATES}"
            if echo "${STATES}" | grep -q "healthy"; then
              HEALTHY=1
              break
            fi
            sleep 10
          done

          if [ "${HEALTHY}" != "1" ]; then
            echo "::error::No healthy targets observed within timeout. Failing."
            aws elbv2 describe-target-health --target-group-arn "${TG_ARN}" --output table || true
            exit 1
          fi

          echo "Targets are healthy ✅"

  ######################################################
  # DNS smoke test — optional custom domain
  ######################################################
  dns_smoke:
    name: DNS Smoke Test
    needs: deploy
    if: ${{ github.event_name == 'push' || inputs.action == 'deploy' }}
    runs-on: ubuntu-latest
    environment: dev

    defaults:
      run:
        working-directory: ${{ env.WORKDIR }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN_APPLY }}
          aws-region: ${{ secrets.AWS_REGION }}
          audience: sts.amazonaws.com

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Terraform init
        run: terraform init -input=false

      - name: Resolve target URL
        id: url
        shell: bash
        run: |
          set -euo pipefail
          SMOKE_PATH="${{ inputs.smoke_path }}"
          FQDN="${{ inputs.fqdn }}"
          if [ -n "${FQDN}" ]; then
            echo "url=https://${FQDN}${SMOKE_PATH}" >> $GITHUB_OUTPUT
            exit 0
          fi

          if terraform output -raw alb_dns_name >/dev/null 2>&1; then
            ALB="$(terraform output -raw alb_dns_name)"
          elif terraform output -raw alb_dns >/dev/null 2>&1; then
            ALB="$(terraform output -raw alb_dns)"
          else
            echo "::warning::No ALB DNS outputs found; skipping smoke test"
            echo "url=" >> $GITHUB_OUTPUT
            exit 0
          fi
          echo "url=https://${ALB}${SMOKE_PATH}" >> $GITHUB_OUTPUT

      - name: Smoke test (HTTP 200-399)
        if: ${{ steps.url.outputs.url != '' }}
        shell: bash
        run: |
          set -euo pipefail
          URL="${{ steps.url.outputs.url }}"
          echo "Smoking: ${URL}"
          for i in {1..30}; do
            CODE="$(curl -k -s -o /dev/null -w "%{http_code}" "${URL}" || true)"
            echo "Attempt ${i} — HTTP ${CODE}"
            if [ "${CODE}" -ge 200 ] && [ "${CODE}" -lt 400 ]; then
              echo "Smoke passed ✅"
              exit 0
            fi
            sleep 5
          done
          echo "::error::Smoke test failed after retries"
          exit 1

      - name: No URL to test — skipping
        if: ${{ steps.url.outputs.url == '' }}
        run: |
          echo "No URL available. Skipping smoke test."
          exit 0

  #####################################################
  # Destroy (gated) — appears after deploy/smoke, waits for approval
  ########################################################
  destroy:
    name: Destroy (gated)
    needs: dns_smoke
    if: ${{ github.event_name == 'push' || (github.event_name == 'workflow_dispatch' && inputs.action == 'destroy') }}
    runs-on: ubuntu-latest
    environment: destroy

    defaults:
      run:
        working-directory: ${{ env.WORKDIR }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN_DESTROY || secrets.AWS_ROLE_ARN_APPLY }}
          aws-region: ${{ secrets.AWS_REGION }}
          audience: sts.amazonaws.com

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Terraform init
        run: terraform init -input=false

      - name: Disable ALB deletion protection (controlled teardown) - safe on reruns
        shell: bash
        run: |
          set -euo pipefail

          PREFIX="${{ env.WORKDIR }}"
          NAME_PREFIX="devsecops-flask-dev"

          echo "Searching for ALB(s) to disable deletion protection..."

          ALB_ARNS="$(aws elbv2 describe-load-balancers \
            --query "LoadBalancers[?contains(LoadBalancerName, \`${NAME_PREFIX}\`)].LoadBalancerArn" \
            --output text || true)"

          if [ -z "${ALB_ARNS}" ] || [ "${ALB_ARNS}" = "None" ]; then
            echo "No matching ALB found. Skipping deletion protection disable."
            exit 0
          fi

          for ALB_ARN in ${ALB_ARNS}; do
            echo "Disabling deletion protection for: ${ALB_ARN}"
            aws elbv2 modify-load-balancer-attributes \
              --load-balancer-arn "${ALB_ARN}" \
              --attributes Key=deletion_protection.enabled,Value=false
          done

      - name: Wait for AWS to release public IP mappings (IGW safety)
        shell: bash
        run: |
          set -euo pipefail

          # Safely read vpc_id from terraform outputs without leaking warnings/ANSI into variables.
          VPC_ID=""

          # Get outputs as JSON; if state/outputs missing, this yields '{}' and we skip.
          TF_OUT="$(terraform output -json 2>/dev/null || echo '{}')"

          # Extract vpc_id.value if present
          VPC_ID="$(echo "$TF_OUT" | jq -r '.vpc_id.value // empty' 2>/dev/null || true)"

          if [ -z "${VPC_ID}" ] || [ "${VPC_ID}" = "null" ]; then
            echo "::warning::VPC ID not found in terraform outputs (state missing or no outputs). Skipping wait."
            exit 0
          fi

          echo "Waiting for AWS cleanup in VPC: ${VPC_ID}"

          for i in {1..40}; do
            COUNT="$(aws ec2 describe-network-interfaces \
              --filters Name=vpc-id,Values="${VPC_ID}" \
              --query "length(NetworkInterfaces[?Association.PublicIp!=null])" \
              --output text)"
            echo "Attempt $i — public ENIs with public IPs: $COUNT"
            if [ "$COUNT" = "0" ]; then
              echo "AWS cleanup complete ✅"
              exit 0
            fi
            sleep 15
          done

          echo "::warning::AWS cleanup timeout reached, proceeding anyway"

      - name: Terraform destroy
        run: terraform destroy -auto-approve -parallelism=1
